% This presentation was created for the
% LA Ruby/Rails Meetup hosted at
% Radpad, Inc.
\documentclass{beamer}
\usepackage{listings}
\usepackage{tabularx}
\usepackage{beamerthemeshadow}
\begin{document}
\title{Ruby Internals and Optimization}  
\author{Sunil Pinnamaneni}
\titlegraphic{\includegraphics[width=\textwidth,height=.2\textheight]{Radpad.png}}
\institute{Software Architect\\ \footnotesize Radpad, Inc.}
\date{\today} 

\frame{\titlepage} 

\frame{\frametitle{Table of contents}\tableofcontents} 


\section{Ruby Internals} 
\subsection{Ruby Code to Execution}
\frame{\frametitle{Ruby Code to Execution}
\begin{enumerate}
\item Tokenization
  \begin{itemize}
    \item Ruby Code $->$ Tokens
    \item Tokenization done by parser\_yylex function
  \end{itemize} \pause
\item Parsing
  \begin{itemize}
    \item Tokens $->$ AST Nodes (AST = Abstract Syntax Tree)
    \item LALR Parse Algorithm used (Look-Ahead Left Reversed Rightmost Derivation)
    \item Parsing done by parse.c, which is generated by Bison
  \end{itemize} \pause
\item Compilation
  \begin{itemize}
    \item AST Nodes $->$ YARV Instruction (YARV = Yet Another Ruby Virtual Machine)
    \item Compilation done by compile.c
  \end{itemize} \pause
\item YARV Executes Instructions
  \begin{itemize}
    \item C code for YARV instructions in insns.def
  \end{itemize}
\end{enumerate}
}

\subsection{describer.rb}
\frame{\frametitle{describer.rb}
\begin{itemize}
\item Understand tokenization, parsing, and compilation through an example \pause
\item Use describer.rb
\begin{itemize}
\item describer.rb takes Ruby code as input.
\item outputs a tokenization, AST Nodes, and YARV instructions
\item describer.rb is available on Github \pause
\begin{enumerate}
\item git clone https://github.com/raisin/Describer.git
\item cd Describer
\item ruby describer.rb './sample\_code/sample\_code.rb’
\item Files are generated inside sample\_code directory.
\end{enumerate}
\end{itemize}
\end{itemize} 
}

\defverbatim[colored]\lstI{
\begin{lstlisting}[language=Ruby,basicstyle=\ttfamily,keywordstyle=\color{red}]
if 2+2 > 3
  puts 'Welcome to LA Ruby/Rails.'
else
  puts 'Go home'
end
\end{lstlisting}
}

\subsection{Example}
\frame{\frametitle{Ruby Source Code}
\lstI
}

\defverbatim[colored]\lstI{
\begin{lstlisting}[language=Ruby,basicstyle=\ttfamily,keywordstyle=\color{red}]
[[1, 0], :on_kw, "if"]
[[1, 2], :on_sp, " "]
[[1, 3], :on_int, "2"]
[[1, 4], :on_op, "+"]
[[1, 5], :on_int, "2"]
[[1, 6], :on_sp, " "]
[[1, 7], :on_op, ">"]
[[1, 8], :on_sp, " "]
[[1, 9], :on_int, "3"]
[[1, 10], :on_nl, "\n"]
[[2, 0], :on_sp, " "]
[[2, 2], :on_ident, "puts"]
[[2, 6], :on_sp, " "]
\end{lstlisting}
}

\frame{\frametitle{Tokenization 1 of 3}
\lstI
}

\defverbatim[colored]\lstI{
\begin{lstlisting}[language=Ruby,basicstyle=\ttfamily,keywordstyle=\color{red}]
[[2, 7], :on_tstring_beg, "’"]
[[2, 8], :on_tstring_content, "Welcome to LA Ruby/Rails."]
[[2, 33], :on_tstring_end, "’"]
[[2, 34], :on_nl, "\n"]
[[3, 0], :on_kw, "else"]
[[3, 4], :on_ignored_nl, "\n"]
[[4, 0], :on_sp, " "]
[[4, 2], :on_ident, "puts"]
[[4, 6], :on_sp, " "]
[[4, 7], :on_tstring_beg, "’"]
[[4, 8], :on_tstring_content, "Go home"]
[[4, 15], :on_tstring_end, "’"]
[[4, 16], :on_nl, "\n"]
\end{lstlisting}
}

\frame{\frametitle{Tokenization 2 of 3}
\lstI
}

\defverbatim[colored]\lstI{
\begin{lstlisting}[language=Ruby,basicstyle=\ttfamily,keywordstyle=\color{red}]
[[5, 0], :on_kw, "end"]
[[5, 3], :on_nl, "\n"]
[[6, 0], :on_ignored_nl, "\n"]
\end{lstlisting}
}

\frame{\frametitle{Tokenization 3 of 3}
\lstI
}

\defverbatim[colored]\lstI{
\begin{lstlisting}[language=Ruby,basicstyle=\ttfamily,keywordstyle=\color{red}]
[:program, [[:if,
[:binary,
[:binary, [:@int, "2", [1, 3]], :+, [:@int, "2", [1, 5]]], :>,
[:@int, "3", [1, 9]]],
[[:command,
[:@ident, "puts", [2, 2]], [:args_add_block,
[[:string_literal, [:string_content,
[:@tstring_content, "Welcome to LA Ruby/Rails.", [2, 8]]]]], false]]],
\end{lstlisting}
}

\frame{\frametitle{AST Nodes 1 of 2}
\lstI
}

\defverbatim[colored]\lstI{
\begin{lstlisting}[language=Ruby,basicstyle=\ttfamily,keywordstyle=\color{red}]
[:else, [[:command,
[:@ident, "puts", [4, 2]], [:args_add_block,
[[:string_literal,
[:string_content, [:@tstring_content, "Go home", [4, 8]]]]],
false]]]]]]]
\end{lstlisting}
}

\frame{\frametitle{AST Nodes 1 of 2}
\lstI
}

\defverbatim[colored]\lstI{
\begin{lstlisting}[language=Ruby,basicstyle=\ttfamily,keywordstyle=\color{red}]
== disasm: #<ISeq:<compiled>@<compiled> >===================
0000 trace 1 ( 1)
0002 putobject 2
0004 putobject 2
0006 opt_plus <callinfo!mid:+, argc:1, ARGS_SIMPLE>,
<callcache>
0009 putobject 3
0011 opt_gt <callinfo!mid:>, argc:1, ARGS_SIMPLE>,
<callcache>
0014 branchunless 25
0016 trace 1 ( 2)
0018 putself
0019 putstring "Welcome to LA Ruby/Rails."
\end{lstlisting}
}

\frame{\frametitle{YARV Instructions 1 of 2}
\lstI
}

\defverbatim[colored]\lstI{
\begin{lstlisting}[language=Ruby,basicstyle=\ttfamily,keywordstyle=\color{red}]
0021 opt_send_without_block <callinfo!mid:puts, argc:1, FCALL|ARGS_SIMPLE>, <callcache>
0024 leave ( 1)
0025 trace 1 ( 4)
0027 putself
0028 putstring "Go home"
0030 opt_send_without_block <callinfo!mid:puts, argc:1, FCALL|ARGS_SIMPLE>, <callcache>
0033 leave
\end{lstlisting}
}

\frame{\frametitle{YARV Instructions 2 of 2}
\lstI
}

\frame{\frametitle{More about the YARV}
\begin{itemize}
\item Ruby 1.8.7 directly interprets the AST Nodes.
\item YARV first introduced in Ruby 1.9.x to speed up Ruby.
\item The compilation step made Ruby faster. It was 4.25 times faster on a simple while loop that incremented an integer.
\item Across a wider set of benchmarks, some people said it’s approximately 4x faster.
\end{itemize}
}

\subsection{Ruby Implementations}
\frame{\frametitle{Ruby Implementations}
\centering
\tiny
\begin{tabular}{| c | c | c | c | c | c |}
MRI 1.8.7 & MRI 1.9+ & JRuby & Rubinius & Iron Ruby & JRuby + Truffle \\
Tokens & Tokens & Tokens & Tokens & Tokens & Tokens \\
AST Nodes & AST Nodes & AST Nodes & AST Nodes & AST Nodes & Multiple ASTs \\
Interpreter & YARV Inst & Java ByteCode & Rubinius Inst & CLR ByteCode & Machine Code Methods \\
Machine Inst & Compiled C Inst & Machine Inst & LLVM Inst & Machine Inst & * \\
* & Machine Inst & * & Machine Inst & * & * \\
\end{tabular}
}

\section{Optimizing Ruby}
\subsection{Speed Of Machine Operations}
\frame{\frametitle{Speed Of Machine Operations}
\begin{itemize}
\item Register Operations: 1/2 ns on 2GHz processor \pause
\item L1 Cache Access: 4ns \pause
\item L2 Cache Access: 40ns \pause
\item Main Memmory(same CPU) 80ns \pause
\item Main Memmory(different CPU) 320ns \pause
\item Ping(local network) 400,000ns
\end{itemize}
}

\subsection{Hard Features to Optimize}
\frame{\frametitle{Hard Features to Optimize}
\begin{enumerate}
\item Fixnum to Bignum Promotion
  \begin {itemize}
    \item Extra Machine Code for every arithmatic operation
    \item More register operations are required
  \end {itemize} \pause
\item Monkey Patching Methods
  \begin {itemize}
    \item Checks for method redefinition - requires cache access
    \item Recovery code path for method redefinition - requires register
operations
  \end {itemize} \pause
\item Bindings and Eval
  \begin {itemize}
    \item Access \& Update of bindings on heap - L2 \& memmory access
    \item Blocks can be turned into Procs - L2 \& memory access
  \end {itemize} \pause
\item Tracing and Debugging - REPL Loop - See \#3 \pause
\item ObjectSpace
  \begin {itemize}
    \item JVM - no GC access - have to track objects
    \item Escape Analysis with bindings - memory access
  \end {itemize}
\end {enumerate}
}

\frame{\frametitle{Hard Features to Optimize}
\begin{enumerate}
\item Garbage Collection and Object Allocation
  \begin {itemize}
    \item Garbage collection is tricky
  \end {itemize} \pause
\item set\_trace\_func
  \begin {itemize}
    \item Allows Procs to be called on every line or on events
    \item Prevents JIT compilation - register OPs \& L2 \& memory access
operations
  \end {itemize} \pause
\item Thread\#raise
  \begin {itemize}
    \item Threads can kill or raise each other - Requires periodic checks
    \item More register OPs \& L2 \& memory access
  \end {itemize} \pause
\item Ruby blocks
  \begin {itemize}
    \item Frame local data can change unlike Java inner classes and lamdas
    \item Requires memory access
  \end {itemize}
\end {enumerate}
}

\frame{\frametitle{Hard Features to Optimize}
\begin{enumerate}
\item C extension support
  \begin {itemize}
    \item Compiling C to Java Bytecode ???
    \item More register operations
  \end {itemize} \pause
\item Concurrency\/Parallelism
  \begin {itemize}
    \item Have to deal with cross-thread events
    \item Thread-safety of Ruby data structures requires cache calls
    \item More register OPs \& L2 \& memory access
  \end {itemize}
\end {enumerate}
}

\section{Appendix}
\subsection{Sources}
\frame{\frametitle{Sources}
\begin{enumerate}
\item Ruby Under a Microscope : An Illustrated Guide to Ruby Internals; Pat Shaughnessy
\item http://chrisseaton.com/rubytruffle ; Chris Seaton
  \begin {itemize}
    \item Deoptimizing Ruby
    \item Very High Performance C Extensions For JRuby + Truffle
    \item Optimizing Small Data Structures in JRuby + Truffle
    \item  A Truffe\/Graal High Performance Backend for JRuby
  \end {itemize}
\item http://blog.headius.com/2012/10/so-you-want-to-optimize- ruby.html ; Charles
Nutter
  \begin {itemize}
    \item So You Want To Optimize Ruby
  \end {itemize}
\end {enumerate}
}

\end{document}
